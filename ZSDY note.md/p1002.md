# 过河卒（p1002 洛谷）

### 题目

    棋盘上 AA 点有一个过河卒，需要走到目标 BB 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 CC 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。

    棋盘用坐标表示，AA 点 (0, 0)(0,0)、BB 点 (n, m)(n,m)，同样马的位置坐标是需要给出的。

### 普通方法
    #include<iostream>
    #include<algorithm>//新的头文件，数值有关 

    using namespace std;

    //很巧的特殊处理 
    const int aj[]={0,1,2,1,2,-1,-2,-1,-2}; 
    const int ak[]={0,2,1,-2,-1,2,1,-2,-1};

    bool mark[9][9];//很巧妙，标记剔除 
    int dp[9][9];

    int main()
    {
        int bx,by,mx,my;
        cin>>bx>>by
            >>mx>>my;
        bx+=2;by+=2;mx+=2;my+=2;
        
        for(int i=0;i<9;i++){//以前想用for然后if else剔除，没有这方便 
            mark[mx+aj[i]][my+ak[i]]=1;
        }
        
        dp[2][2]=1;
        for(int i=2;i<=bx;i++){
            for(int s=2;s<=by;s++){
                if(mark[i][s]) continue;//mark标记剔除 
                dp[i][s]=max(dp[i][s],dp[i-1][s]+dp[i][s-1]);
            }
        }
        cout<<dp[bx][by];
        
        return 0;
    }

## 分析
1.题目的计算角度。 如果不是以前做过就很难做出

        **要从简单角度来看**，

2.技巧积累。
    
    if else剔除特殊情况，数组用数组标记

    细节上的思考，用的简单方法，如跨界

    简便，用时，代码长度都要看

## 简化点：f[i][j]=f[i−1][j]+f[i][j−1]
    每次出现在方程，发f[i][j]，f[i−1][j]，f[i][j−1]

    二维数组过大   运算时出现浪费

    dp[2][9]和dp[9];

dp[2][9]情况

    滚动数组，用if else 不方便判断，** 位运算 **

    如果a&1=1；a为奇数，反之为；

    f[i&1][j]=f[i&1][j]+f[i&1-1][j-1];

dp[9]情况

    f[i]=f[i]+f[i-1];
    看似很疯狂；但实际思考细密
    因为，f[i]的值还停留，在上一个，即f[i-1][j];
### 最强分析 从代码的细节着手，将代码化简
    


    
 


